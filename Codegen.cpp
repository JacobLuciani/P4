//---------------------------------------------------------------------------
//File name: Codegen.cpp
//Author: Jacob Luciani
//Purpose: Provides functionality for recursive asm code-generation traversal of 
//         parse tree
//---------------------------------------------------------------------------

#include "Codegen.h"

//counts autogenerated labels to ensure unique names
static int labelCntr=0;

//counts temporary variables created to ensure unique names and storage allocation
static int varCntr=0;

//stores unique temporary variable/label names
static string Name;

//tracks initial values of introduced variables for the storage allocation section of asm code
stringstream varBuffer;

//generates a temporary name for a label or variable
//Thanks to Professor Hauschild for structure
static string newName(nameType what) {
	
	//buffer used to construct name
	stringstream buffer;
	
	//creates a temporary variable name
	if (what==VAR) {
		
		buffer << "V" << varCntr++; //increment counter to ensure unique name generation
		
		//convert to string
		Name = buffer.str();
		
	} else {
		
		buffer << "L" << labelCntr++;//increment counter to ensure unique name generation

		//convert to string
		Name = buffer.str();
	}
	
	return(Name);
}

//recursively travel tree, storing output code in file with an ofstream object
//Thanks to Professor Hauschild for structure
void recGen(Node *root, ofstream& out) 
{ 
	//storage for names of autogenerated variables/labels
	string label, label2, name, name2;

	//no nodes, do nothing
	if (root == NULL) {
		return; 
	}
	
	//get type of node currently being processed
	string type = root->type;
	
	//based on type of node, generate specific code patterns
	if (type == "program") {
		
		recGen(root->branch1, out); //vars
		recGen(root->branch2, out); //block
		
		//end of program
		out << "STOP\n";
		
		//storage allocation for non-autogenerated variables
		out << varBuffer.str();
		
		//storage allocation for autogenerated variables
		for (int i = 0; i < varCntr; i++) {
			out << "V" << i << " 0\n";
		}
		return;
		
	} else if (type == "vars") {
		
		//add variable to buffer collecting code-sourced variables and their initial values
		//will be printed after the STOP and before autogenerated variable storage allocation
		varBuffer << root->members[0].tokenInstance << " " << root->members[1].tokenInstance << "\n";
		
		//process next vars in list, if present
		recGen(root->branch1, out);
		return;
		
	} else if (type == "block") {
		
		recGen(root->branch1, out); //vars
		recGen(root->branch2, out); //stats
		return;
		
	} else if (type == "expr") {

		recGen(root->branch1, out); //N
		
		//subtraction code needs to be generated
		if (!root->members.empty()) {

			//store accumulator value for later use
			name = newName(VAR);
			out << "STORE " << name << "\n";
			
			recGen(root->branch2, out); //process rhs
			name2 = newName(VAR); //store rhs result
			
			//subtraction operation
			out << "STORE " << name2 << "\n";
			out << "LOAD " << name << "\n";
			out << "SUB " << name2 << "\n";
			
		}
		
		return;
		
	} else if (type == "N") {

		recGen(root->branch1, out); //A
		
		//Multiplication or division found
		if(!root->members.empty()) {

			//store value in accumulator for later use
			name = newName(VAR);
			out << "STORE " << name << "\n";
			
			recGen(root->branch2, out); //A, rhs
			
			name2 = newName(VAR);
			out << "STORE " << name2 << "\n";
			
			out << "LOAD " << name << "\n";
			
			//perform mult/div as needed
			if (root->members[0].tokenInstance == "*") {
				out << "MULT " << name2 << "\n";
			} else if (root->members[0].tokenInstance == "/") {
				out << "DIV " << name2 << "\n";
			}
		}
		
		return;
		
	} else if (type == "A") {

		recGen(root->branch1, out); //M
		
		//Addition found
		if (!root->members.empty()) {

			//Store value in accumulator for later use
			name = newName(VAR);
			out << "STORE " << name << "\n";
			
			//get rhs and add stored value
			recGen(root->branch2, out);
			out << "ADD " << name << "\n";
		}
		return;
		
	} else if (type == "M") {

		//* symbol found
		if (!root->members.empty()) {
			
			//store accumulator value while rhs is being evaluated
			name = newName(VAR);
			out << "STORE " << name << "\n";
			
			//rhs and operation
			recGen(root->branch1, out);
			out << "MULT " << name << "\n";
		} else {
			recGen(root->branch1, out); //R
		}
		return;
		
	} else if (type == "R") {

		//check which production rule was used
		if (root->members.empty()) { // (expr)
			recGen(root->branch1, out);
		} else { //identifier or number
			//operation is the same for either id or num: LOAD
			out << "LOAD " << root->members[0].tokenInstance << "\n";
		}
		return;
		
	} else if (type == "stats") {
		
		recGen(root->branch1, out); //stat
		recGen(root->branch2, out); //mStat
		
		return;
		
	} else if (type == "mStat") {
		
		recGen(root->branch1, out); //stat or empty
		recGen(root->branch2, out); //mStat or empty
		
		return;
		
	} else if (type == "stat") {
		//pass through to more specific node
		recGen(root->branch1, out);
		
		return;
		
	}else if (type == "in") {
		
		//take input and store in identifier contained in token
		out << "READ " << root->members[0].tokenInstance << "\n";

		return;
		
	} else if (type == "out") {
		
		//evaluate expression for output
		recGen(root->branch1, out);
		
		//create temp var for write command
		name = newName(VAR);
		out << "STORE " << name << "\n";
		out << "WRITE " << name << "\n";
		
		return;
		
	}else if (type == "assign") {
		
		//generate value for rhs of expression in accumulator
		recGen(root->branch1, out);
		
		//assign expr value, now in accumulator, to the identifier in the token at current node
		out << "STORE " << root->members[0].tokenInstance << "\n";
		
		return;
		
	} else if (type == "if") {
		
		//process lhs of conditional and store
		recGen(root->branch1, out);
		name = newName(VAR);
		out << "STORE " << name << "\n";
		
		//process rhs of conditional
		recGen(root->branch3, out);
		
		//compute difference
		out << "SUB " << name << "\n";
		
		//target BR statements for given RO pattern:
		// x <  y => (y-x>0) BRZNEG
		// x << y => (y-x>=0) BRNEG
		// x == y => (y-x==0) BRPOS OR BRNEG
		// x >> y => (y-x<=0) BRPOS
		// x >  y => (y-x<0) BRZPOS
		// x <> y => (y-x!=0) BRZERO
		
		//generate label for post-iffy target
		label = newName(LABEL);
		
		//retrieve the node associated with the conditional
		Node *branch = root->branch2;
		
		//check if conditional is == - this must be handled here, not in the RO node
		if (branch->members.size() == 1 && branch->members[0].tokenInstance == "==") {
			//skip to target if ACC is either > or < 0
			out << "BRNEG " << label << "\n";
			out << "BRPOS " << label << "\n";
		} else {
			//generate proper BR statement according to RO node
			recGen(root->branch2, out);
			
			//apply label to BR statement
			out << " " << label << "\n";
		}
		
		//dependent statements
        recGen(root->branch4, out);
		
		//post-iffy skip target
		out << label << ": NOOP\n";
		
		return;
	} else if (type == "loop") {
		
		//generate and print label for head target - to be returned to after each loop
		label2 = newName(LABEL);
		out << label2 << ": NOOP\n";
		
		//process lhs of conditional and store
		recGen(root->branch1, out);
		name = newName(VAR);
		out << "STORE " << name << "\n";
		
		//process rhs of conditional
		recGen(root->branch3, out);
		
		//compute difference
		out << "SUB " << name << "\n";
		
		//target BR statements for given RO pattern:
		// x <  y => (y-x>0) BRZNEG
		// x << y => (y-x>=0) BRNEG
		// x == y => (y-x==0) BRPOS OR BRNEG
		// x >> y => (y-x<=0) BRPOS
		// x >  y => (y-x<0) BRZPOS
		// x <> y => (y-x!=0) BRZERO
		
		//generate label for post-loop target
		label = newName(LABEL);
		
		//retrieve the node associated with the conditional
		Node *branch = root->branch2;
		
		//check if conditional is == - this must be handled here, not in the RO node
		if (branch->members.size() == 1 && branch->members[0].tokenInstance == "==") {
			//skip to target if ACC is either > or < 0
			out << "BRNEG " << label << "\n";
			out << "BRPOS " << label << "\n";
		} else {
			//generate proper BR statement according to RO node
			recGen(root->branch2, out);
			
			//apply label to BR statement
			out << " " << label << "\n";
		}
		
		//dependent statements
        recGen(root->branch4, out);
		
		//return to head of loop and reevaluate
		out << "BR " << label2 << "\n";
		
		//post-loop skip target
		out << label << ": NOOP\n";
		
		return;
	}else if (type == "RO") {
		
		//based on RO contents, generate appropriate BR statement for iffy/loop
		
		//check size (for >>/<</< >)
		int size = root->members.size();
		Token token = root->members[0];
		Token token2; //for the second character if needed
		
		//if/else block to determine appropriate BR statement
		if (token.tokenInstance == "<") {
			if (size == 2) {
				token2 = root->members[1];
				if (token2.tokenInstance == "<") {
					out << "BRNEG";
				} else if (token2.tokenInstance == ">") {
					out << "BRZERO";
				}
			} else {
				out << "BRZNEG";
			}
		} else if (token.tokenInstance == ">") {
			if (size == 2) {
				token2 = root->members[1];
				if (token2.tokenInstance == ">") {
					out << "BRPOS";
				}
			} else {
				out << "BRZPOS";
			}
		}
		return;
	} else if (type == "label") {
		//blank label statement generated
		out << root->members[0].tokenInstance << ": NOOP\n";
		
		return;
	} else if (type == "goto") {
		//simple BR statement to associated label
		out << "BR " << root->members[0].tokenInstance << "\n";
		
		return;
	}
		
}